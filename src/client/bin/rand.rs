use std::fs::File;
use std::net::TcpStream;
use std::io::Write;
use std::io::Read;
use chacha20::ChaCha20;
use chacha20::cipher::{KeyIvInit, StreamCipher};
use byteorder::{LittleEndian, ByteOrder};

#[path = "../../constants/constants.rs"]
mod constants;
use crate::constants::{HASH_SIZE};

use crate::params;

const BUF_SIZE: usize = 64;
const DEFAULT_NUM_BYTES: usize = 64;
const DEFAULT_FORMAT: &str = "bytes";

const ALPHA_LOWER: &str = "abcdefghijklmnopqrstuvwxyz";
const ALPHA_UPPER: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const DIGITS: &str = "0123456789";
const SYMBOLS: &str = "~!@#$%^&*()-_=+[{]}|;:'\",<.>/?";


// called from main when the `rand` command is given on command line
// handles everything
pub fn handle_rand(stream: &mut TcpStream, args: &Vec<String>) {

  // handle num_bytes parameter
  let num_bytes = params::get_param(&args, "-n");
  let num_bytes = match num_bytes {
    Ok(x) => x.parse::<usize>().unwrap_or_else(|_| {
      eprintln!("must give integer argument to -n flag");
      std::process::exit(1);
      }),
    Err(_) => DEFAULT_NUM_BYTES,
  };

  // handle format parameter
  let format = params::get_param(&args, "-f");
  let format = match format {
    Ok(x) => x,
    Err(_) => DEFAULT_FORMAT,
  };

  // harden parameters
  let harden: bool = args.contains(&"--harden".to_string());

  //let rand_out = rand_from_daemon(stream, args[2].parse::<usize>().unwrap());
  let rand_out = rand_from_daemon(stream, num_bytes, harden);
  let rand_out = match rand_out {
    Ok(rand_out) => rand_out,
    Err(e) => {
      eprintln!("error: {}", e);
      std::process::exit(1);
    }
  };

  let mut buffer: String = "".to_owned();
  match format {
    "bytes" => std::io::stdout().write_all(&rand_out).unwrap(),
    "hex" => println!("{}",hex::encode(&rand_out)),

    // string types
    "binary" => {
      for i in 0..rand_out.len() {
        let tmp = rand_out[i];
        print!("{tmp:b}")
      }
      println!("");
    },
    "digits" => {
      rand_from_charset(&DIGITS, rand_out, &mut buffer);
      println!("{}",buffer);
    },
    "alpha-numeric" => {
      let charset = format!("{}{}", ALPHA_LOWER, DIGITS);
      rand_from_charset(&charset, rand_out, &mut buffer);
      println!("{}",buffer);
    },
    "Alpha-numeric" => {
      let charset = format!("{}{}{}", ALPHA_LOWER, DIGITS, ALPHA_UPPER);
      rand_from_charset(&charset, rand_out, &mut buffer);
      println!("{}",buffer);
    },
    "ascii" => {
      let charset = format!("{}{}{}{}", ALPHA_LOWER, DIGITS, ALPHA_UPPER, SYMBOLS);
      rand_from_charset(&charset, rand_out, &mut buffer);
      println!("{}",buffer);
    },

    // ints
    "u8" => {
      let range = get_u8_range_args(args);
      let result: Vec<u8> = extract_u8s(range, &rand_out);
      println!("{:?}", result);
    },
    "u16" => {
      let range = get_u16_range_args(args);
      let result: Vec<u16> = extract_u16s(range, &rand_out);
      println!("{:?}", result);
    },
    _ => {
    eprintln!("invalid format");
    std::process::exit(1);
    }
  }
}

// get the min/max range for u8 from command line
// if none is given, the range [0, 256) is assumed, and this is indicated
// by a return value of None 256 range cannot be represented by u8s so we
// need a separate type of return for this
fn get_u8_range_args(args: &Vec<String>) -> Option<(u8, u8)> {
  if !args.contains(&"--range".to_string()) {
    return None;
  }
  let index = args.iter().position(|x| x == "--range").unwrap() + 1;
  let a = args[index].parse::<u8>().expect("not in u8 range");
  let b = args[index+1].parse::<u8>().expect("not in u8 range");
  Some((a,b))
}

// same as u8
fn get_u16_range_args(args: &Vec<String>) -> Option<(u16, u16)> {
  if !args.contains(&"--range".to_string()) {
    return None;
  }
  let index = args.iter().position(|x| x == "--range").unwrap() + 1;
  let a = args[index].parse::<u16>().expect("not in u16 range");
  let b = args[index+1].parse::<u16>().expect("not in u16 range");
  Some((a,b))
}
  

// return vec of u16s from the random output generated by chacha,
// according to range object (None = default u16 range)
fn extract_u16s(range: Option<(u16, u16)>, r: &[u8]) -> Vec<u16> {

  let mut i: usize = 0;
  let mut ret: Vec<u16> = Vec::new();
  while i < r.len() - 1 {
    let raw: u16 = LittleEndian::read_u16(&r[i..i+2]);
    match range {
      Some(range) => {
        let unbiased = unbiased_u16(range.0, range.1, raw);
        match unbiased {
          Some(x) => ret.push(x),
          None => (),
        };
      },
      None => ret.push(raw),
    }
    i += 2;
  }
  return ret;

}

// return vec of u8s from the random output generated by chacha,
// according to range object (None = default u8 range)
fn extract_u8s(range: Option<(u8, u8)>, r: &[u8]) -> Vec<u8> {
  let mut i: usize = 0;
  let mut ret: Vec<u8> = Vec::new();
  while i < r.len() {
    let raw: u8 = r[i];
    match range {
      Some(range) => {
        let unbiased = unbiased_u8(range.0, range.1, raw);
        match unbiased {
          Some(x) => ret.push(x),
          None => (),
        };
      },
      None => ret.push(raw),
    }
    i += 1;
  }
  return ret;
}

// returns a Result with a random value in [a, b) if success
fn unbiased_u8(a: u8, b: u8, r: u8) -> Option<u8> {

  if b <= a {
    eprintln!("Error: invalid range");
    std::process::exit(1);
  }

  let range = b - a;
  let divisor: u8 = ((!range) / range) + 1;
  if divisor == 0 { //overflow is 2**8
    return Some(0);
  }
  let val: u8 = r / divisor;
  if val < range {
    return Some(val + a);
  }
  None
}

// returns a Result with a random value in [a, b) if success
fn unbiased_u16(a: u16, b: u16, r: u16) -> Option<u16> {

  if b <= a {
    eprintln!("Error: invalid range");
    std::process::exit(1);
  }

  let range = b - a;
  let divisor: u16 = ((!range) / range) + 1;
  if divisor == 0 { //overflow is 2**8
    return Some(0);
  }
  let val: u16 = r / divisor;
  if val < range {
    return Some(val + a);
  }
  None
}

// append (uniform) randomly chosen characters from charset, with source randomnes
// from `rand` vec, to buffer
fn rand_from_charset<'a>(charset: &'a str, rand: Vec<u8>, buffer: &'a mut String) {

  let n: u8 = charset.len().try_into().expect("invalid conversion");
  for i in 0..rand.len() {
    let r = unbiased_u8(0, n, rand[i]);
    match r {
      Some(x) => {
        let index: usize = usize::try_from(x).unwrap(); 
        buffer.push_str(&charset[index..index+1]);
      },
      None => (),
    }
  }

}
  
// generate random vec<u8> based on seed retrieved from daemon
fn rand_from_daemon(stream: &mut TcpStream, n: usize, harden: bool) -> Result<Vec<u8>, String> {

  // get key from daemon
  let mut buf: [u8; BUF_SIZE] = [0; BUF_SIZE];
  stream.write(b"rand").expect("failed to write to stream");
  stream.read(&mut buf).expect("failed to read from stream");

  // insufficient entropy
  if buf[HASH_SIZE] != 0 {
    return Err("no hash from server due to insufficient entropy".to_string());
  }

  let mut key: [u8; HASH_SIZE] = {
    let mut key = [0u8; HASH_SIZE];
    for i in 0..HASH_SIZE { key[i] = buf[i]; }
    key
  };
  let nonce = [0; 12];
  
  let mut plaintext: Vec<u8> = vec![0; n];

  if harden {

    let mut dev_urandom: Vec<u8> = vec![0; HASH_SIZE];
    let mut f = File::open("/dev/urandom").unwrap();
    f.read_exact(&mut dev_urandom).unwrap();

    // xor urandom output with key
    for i in 0..HASH_SIZE {
      key[i] = key[i] ^ dev_urandom[i];
    }
  }

  //println!("plaintext was: {:?}", plaintext);

  let mut cipher = ChaCha20::new(&key.into(), &nonce.into());
  cipher.apply_keystream(&mut plaintext);
  return Ok(plaintext);
}

